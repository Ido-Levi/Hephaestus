diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py
index 593048464b..8138b65644 100644
--- a/sympy/geometry/point.py
+++ b/sympy/geometry/point.py
@@ -234,6 +234,45 @@ def ambient_dimension(self):
         will be n"""
         return len(self)
 
+    def _normalize_dimensions(self, other):
+        """Return coordinate tuples normalized to same dimension with zeros.
+
+        When operating on points of different dimensions, this method pads
+        the shorter point's coordinates with zeros to match the longer point.
+        This ensures all dimensions are considered in calculations.
+
+        Parameters
+        ==========
+
+        other : Point or sequence
+            The other point or coordinate sequence to normalize with self.
+
+        Returns
+        =======
+
+        self_padded, other_padded : tuple, tuple
+            Two coordinate tuples of equal length, padded with S.Zero as needed.
+
+        Examples
+        ========
+
+        >>> from sympy.geometry import Point
+        >>> p1 = Point(1, 2)
+        >>> p2 = Point(3, 4, 5)
+        >>> p1._normalize_dimensions(p2)
+        ((1, 2, 0), (3, 4, 5))
+
+        """
+        if isinstance(other, Point):
+            other_coords = other.args
+        else:
+            other_coords = other
+
+        max_len = max(len(self.args), len(other_coords))
+        self_padded = tuple(list(self.args) + [S.Zero] * (max_len - len(self.args)))
+        other_padded = tuple(list(other_coords) + [S.Zero] * (max_len - len(other_coords)))
+        return self_padded, other_padded
+
     def distance(self, p):
         """The Euclidean distance from self to point p.
 
@@ -266,8 +305,8 @@ def distance(self, p):
         sqrt(x**2 + y**2)
 
         """
-        return sqrt(sum([(a - b)**2 for a, b in zip(
-            self.args, p.args if isinstance(p, Point) else p)]))
+        self_coords, p_coords = self._normalize_dimensions(p)
+        return sqrt(sum([(a - b)**2 for a, b in zip(self_coords, p_coords)]))
 
     def taxicab_distance(self, p):
         """The Taxicab Distance from self to point p.
@@ -299,8 +338,8 @@ def taxicab_distance(self, p):
         7
 
         """
-        p = Point(p)
-        return sum(abs(a - b) for a, b in zip(self.args, p.args))
+        self_coords, p_coords = self._normalize_dimensions(p)
+        return sum(abs(a - b) for a, b in zip(self_coords, p_coords))
 
     def midpoint(self, p):
         """The midpoint between self and point p.
@@ -329,7 +368,8 @@ def midpoint(self, p):
         Point2D(7, 3)
 
         """
-        return Point([simplify((a + b)*S.Half) for a, b in zip(self.args, p.args)])
+        self_coords, p_coords = self._normalize_dimensions(p)
+        return Point([simplify((a + b)*S.Half) for a, b in zip(self_coords, p_coords)])
 
     def evalf(self, prec=None, **options):
         """Evaluate the coordinates of the point.
@@ -405,8 +445,8 @@ def intersection(self, o):
 
     def dot(self, p2):
         """Return dot product of self with another Point."""
-        p2 = Point(p2)
-        return Add(*[a*b for a,b in zip(self, p2)])
+        self_coords, p2_coords = self._normalize_dimensions(p2)
+        return Add(*[a*b for a,b in zip(self_coords, p2_coords)])
 
     def equals(self, other):
         """Returns whether the coordinates of self and other agree."""
